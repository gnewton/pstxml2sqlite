package main

/////////////////////////////////////////////////////////////////
//Initial code generated by chidley https://github.com/gnewton/chidley //
/////////////////////////////////////////////////////////////////

import (
	"database/sql"
	"encoding/xml"
	lib "github.com/gnewton/pstxml2sqlite/pstxml2sqlitestructs"
	"github.com/jinzhu/gorm"
	_ "github.com/jinzhu/gorm/dialects/sqlite"
	"log"
	"os"
	"runtime"
	"runtime/pprof"
	"sync"
)

const chunkSize = 300
const TxSize = 5000
const TxLengthSize = 40000000
const NumWorkers = 5

const (
	JsonOut = iota
	XmlOut
	CountAll
)

//var filenames = []string{"/home/gnewton/aafc_email_pst/all.xml.bz2"}

//var filenames = []string{"/home/gnewton/work/pst2json/all.xml.bz2"}

//var filenames = []string{"/home/gnewton/work/pst2json/archive_2018_June15.pst.xml.bz2"}

var filenames = []string{"/home/gnewton/work/pst2json/archive.xml.bz2"}

//var filenames = []string{"/home/gnewton/work/pst2json/m"}

//
var counter = 0
var attachCounter int64 = 0
var recipCounter int64 = 0
var countAll int64 = 0
var countAll2 int64 = 0

func main() {
	log.SetFlags(log.LstdFlags | log.Lshortfile)
	prof()
	// ADD check to see if file exists
	// use gorm to create DB
	db, err := gorm.Open("sqlite3", "a.db")
	if err != nil {
		panic("failed to connect database")
	}
	//defer db.Close()

	db.CreateTable(&lib.Message{})
	db.CreateTable(&lib.Recipient{})
	db.CreateTable(&lib.Attachment{})
	db.CreateTable(&lib.Filesource{})
	db.Close()

	db2, err := sql.Open("sqlite3", "file:a.db")
	if err != nil {
		log.Fatal(err)
	}

	err = setPragmas(db2)
	if err != nil {
		log.Fatal(err)
	}

	tx2, err := db2.Begin()
	if err != nil {
		log.Fatal(err)
	}

	//messagesChannel := make(chan []*lib.Message, 200)
	messagesChannel := make(chan []*lib.Message, 10)

	messageStmt, err := newStatement(tx2, messageSql)
	if err != nil {
		log.Fatal(err)
	}

	attachStmt, err := newStatement(tx2, attachmentSql)
	if err != nil {
		log.Fatal(err)
	}

	recipStmt, err := newStatement(tx2, recipSql)
	if err != nil {
		log.Fatal(err)
	}

	var transactionMux, dupMux sync.Mutex

	saver := &MessageSaver{
		tx2:             tx2,
		db2:             db2,
		messagesChannel: messagesChannel,
		messageStmt:     messageStmt,
		attachStmt:      attachStmt,
		recipStmt:       recipStmt,
		transactionMux:  &transactionMux,
		dupMux:          &dupMux,
	}

	var wg sync.WaitGroup

	wg.Add(NumWorkers)
	for i := 0; i < NumWorkers; i++ {
		go saver.run(&wg)
	}

	dups = make(map[string]bool, 0)

	for i := 0; i < len(filenames); i++ {
		filename := filenames[i]
		log.Println("Opening file: " + filename)

		reader, _, err := genericReader(filename)
		if err != nil {
			log.Fatal(err)
			return
		}
		decoder := xml.NewDecoder(reader)

		for {
			token, _ := decoder.Token()
			if token == nil {
				break
			}
			switch se := token.(type) {
			case xml.StartElement:
				handleFeed(saver, se, decoder, messagesChannel)
			}
		}
	}
	endCommit := false
	if chunk != nil {
		countAll2 += int64(len(chunk))
		messagesChannel <- chunk
		endCommit = true
	}
	log.Println("QQ closing messagesChannel")
	close(messagesChannel)
	log.Println("QQ closed messagesChannel")
	log.Println("QQ wg wait")
	wg.Wait()
	log.Println("QQ wg wait DONE")

	if counter > 0 || endCommit {
		log.Println("Final commit")
		err := saver.tx2.Commit()
		if err != nil {
			log.Fatal(err)
		}

	}

	log.Println("Total messages")
	log.Println(countAll)
	log.Println(countAll2)

	f, err := os.Create("memprofile")
	if err != nil {
		log.Fatal("could not create memory profile: ", err)
	}
	defer f.Close()
	runtime.GC() // get up-to-date statistics
	if err := pprof.WriteHeapProfile(f); err != nil {
		log.Fatal("could not write memory profile: ", err)
	}
}

func prof() {
	f, err := os.Create("cpuprofile")
	if err != nil {
		log.Fatal("could not create CPU profile: ", err)
	}
	defer f.Close()
	if err := pprof.StartCPUProfile(f); err != nil {
		log.Fatal("could not start CPU profile: ", err)
	}
}
