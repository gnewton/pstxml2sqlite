package main

/////////////////////////////////////////////////////////////////
//Initial code generated by chidley https://github.com/gnewton/chidley //
/////////////////////////////////////////////////////////////////

import (
	"bufio"
	"compress/bzip2"
	"compress/gzip"
	"encoding/base64"
	"encoding/json"
	"encoding/xml"
	"flag"
	"fmt"
	"strconv"
	//"github.com/davecgh/go-spew/spew"
	lib "github.com/gnewton/pstxml2sqlite/pstxml2sqlitestructs"
	"github.com/jinzhu/gorm"
	_ "github.com/jinzhu/gorm/dialects/sqlite"
	"io"
	"log"
	"os"
	"strings"
)

const (
	JsonOut = iota
	XmlOut
	CountAll
)

var toJson bool = false
var toXml bool = false
var oneLevelDown bool = false
var countAll bool = false
var musage bool = false

var uniqueFlags = []*bool{
	&toJson,
	&toXml,
	&countAll}

var filename = "/home/gnewton/work/pst2json/backup-20170719.pst.old.xml.bz2"

func init() {
	flag.BoolVar(&toJson, "j", toJson, "Convert to JSON")
	flag.BoolVar(&toXml, "x", toXml, "Convert to XML")
	flag.BoolVar(&countAll, "c", countAll, "Count each instance of XML tags")
	flag.BoolVar(&oneLevelDown, "s", oneLevelDown, "Stream XML by using XML elements one down from the root tag. Good for huge XML files (see http://blog.davidsingleton.org/parsing-huge-xml-files-with-go/")
	flag.BoolVar(&musage, "h", musage, "Usage")
	flag.StringVar(&filename, "f", filename, "XML file or URL to read in")
}

var out int = -1

var counters map[string]*int

func main() {

	db, err := gorm.Open("sqlite3", "a.db")
	if err != nil {
		panic("failed to connect database")
	}
	defer db.Close()

	db.CreateTable(&lib.Message{})
	db.CreateTable(&lib.Recipient{})
	db.CreateTable(&lib.Attachment{})

	flag.Parse()

	if musage {
		flag.Usage()
		return
	}

	numSetBools, outFlag := numberOfBoolsSet(uniqueFlags)
	if numSetBools == 0 {
		flag.Usage()
		return
	}

	if numSetBools != 1 {
		flag.Usage()
		log.Fatal("Only one of ", uniqueFlags, " can be set at once")
	}

	reader, xmlFile, err := genericReader(filename)
	if err != nil {
		log.Fatal(err)
		return
	}

	var counter = 0
	tx := db.Begin()

	decoder := xml.NewDecoder(reader)
	counters = make(map[string]*int)
	for {

		token, _ := decoder.Token()
		if token == nil {
			break
		}
		switch se := token.(type) {
		case xml.StartElement:
			handleFeed(se, decoder, outFlag, tx)
		}
		counter = counter + 1
		if counter == 5000 {
			tx.Commit()
			counter = 0
			tx = db.Begin()
		}
		//if idCounter == 100 {
		//break
		//}
	}
	if counter > 0 {
		tx.Commit()
	}
	if xmlFile != nil {
		defer xmlFile.Close()
	}
	if countAll {
		for k, v := range counters {
			fmt.Println(*v, k)
		}
	}
}

var idCounter int64 = 0

func handleFeed(se xml.StartElement, decoder *xml.Decoder, outFlag *bool, db *gorm.DB) {
	fmt.Println(se.Name.Local)
	if se.Name.Local == "message" && se.Name.Space == "" {
		var item lib.Message
		decoder.DecodeElement(&item, &se)
		item.Id = idCounter

		fmt.Println(idCounter)

		db.Create(&item)
		//db.Save(&item)
		if item.Recipients != nil {
			saveRecipients(item.Recipients.Recipient, db)
		}

		if item.Attachments != nil {
			saveAttachments(item.Attachments.Attachment, db)
		}

		idCounter++

	}

	if se.Name.Local == "meta" && se.Name.Space == "" {
		var item lib.Meta
		decoder.DecodeElement(&item, &se)
		switch outFlag {
		case &toJson:
			//writeJson(item)
		case &toXml:
			//writeXml(item)
		}
	}
}

func makeKey(space string, local string) string {
	if space == "" {
		space = "_"
	}
	return space + ":" + local
}

func incrementCounter(space string, local string) {
	key := makeKey(space, local)

	counter, ok := counters[key]
	if !ok {
		n := 1
		counters[key] = &n
	} else {
		newv := *counter + 1
		counters[key] = &newv
	}
}

func genericReader(filename string) (io.Reader, *os.File, error) {
	if filename == "" {
		return bufio.NewReader(os.Stdin), nil, nil
	}
	file, err := os.Open(filename)
	if err != nil {
		return nil, nil, err
	}
	if strings.HasSuffix(filename, "bz2") {
		return bufio.NewReader(bzip2.NewReader(bufio.NewReader(file))), file, err
	}

	if strings.HasSuffix(filename, "gz") {
		reader, err := gzip.NewReader(bufio.NewReader(file))
		if err != nil {
			return nil, nil, err
		}
		return bufio.NewReader(reader), file, err
	}
	return bufio.NewReader(file), file, err
}

func numberOfBoolsSet(a []*bool) (int, *bool) {
	var setBool *bool
	counter := 0
	for i := 0; i < len(a); i++ {
		if *a[i] {
			counter += 1
			setBool = a[i]
		}
	}
	return counter, setBool
}

func saveRecipients(recips []*lib.Recipient, db *gorm.DB) {
	for i := 0; i < len(recips); i++ {
		recip := recips[i]
		recip.MessageId = idCounter
		db.Create(&recip)
		//db.Save(&recip)
	}
}

// We realy only want attachmentType=1, which has the actual file. The others are references.
// From: https://docs.microsoft.com/en-us/office/vba/api/outlook.olattachmenttype
// Name 	  Value 	Description
// olByReference  4 	This value is no longer supported since Microsoft Outlook 2007. Use olByValue to attach a copy of a file in the file system.
// olByValue 	  1 	The attachment is a copy of the original file and can be accessed even if the original file is removed.
// olEmbeddeditem 5 	The attachment is an Outlook message format file (.msg) and is a copy of the original message.
// olOLE 	  6 	The attachment is an OLE document.
//
func saveAttachments(attachments []*lib.Attachment, db *gorm.DB) {
	for i := 0; i < len(attachments); i++ {
		attach := attachments[i]
		log.Println("-----------------------------------------------------------------------")
		log.Println(idCounter)
		log.Println(i)
		log.Println(attach.AttrFilename)

		attach.MessageId = idCounter
		//if attach.Content != nil {
		//attach.Base64Content = attach.Content.Text
		//}
		log.Println("attach.AttrSize")
		log.Println(attach.AttrSize)
		log.Println("attach.Content.Text")
		log.Println(len(attach.Content.Text))
		if len(attach.Content.Text) < 100 {
			log.Println("attach.Content.Text=[" + attach.Content.Text + "]")
		}
		attach.Size = 0
		if len(attach.AttrSize) > 0 {
			size, err := strconv.ParseInt(attach.AttrSize, 10, 64)
			if err != nil {
				log.Fatal(err)
			} else {
				log.Println("size=" + attach.AttrSize)
				attach.Size = size
			}
		}
		if len(attach.Content.Text) > 0 {
			var err error
			attach.RawContent, err = base64.StdEncoding.DecodeString(attach.Content.Text)
			log.Println("rawContentLengfth")
			log.Println(len(attach.RawContent))
			if err != nil {
				log.Fatal(err)
			}
			if len(attach.Content.Text) < 100 {
				log.Println("rawContentLengfth")
				log.Println(string(attach.RawContent))
			}
			attach.RawSize = len(attach.RawContent)
		}

		db.Create(&attach)
		//db.Save(&attach)
		log.Println()
	}
}
